"""
Functions for grouping data objects that belong to the same sample
"""
import re
from dataclasses import dataclass
from typing import TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from core.data_structs.injection import Injection
    from core.data_structs.fingerprint import Fingerprint
    from core.data_structs.feature_table import FeatureTable


@dataclass
class SampleMatchingParams:
    """
    Placeholder; will contain information about how to group
    data files.

    The reason this is only a placeholder is because we use
    a simple, parameter-free algorithm right now
    (i.e. search for fingerprint name in injection filename)
    """

# Defining type
Grouping = tuple[
    Optional['Fingerprint'],
    Optional['Injection'],
    Optional['FeatureTable'],
]


def find_groups(
    injections: list['Injection'],
    fingerprints: list['Fingerprint'],
    feature_table: Optional['FeatureTable'],
    params: SampleMatchingParams = None,
) -> list[Grouping]:
    """
    Groups Injection and Fingerprint objects if they're deemed to
    be from the same sample.

    For now, this is done based on a simple search for the
    fingerprint name in the injection filename.
    TODO: Implement user-customizable method (regex-based?)

    :param params:
    :param injections: List of Injection objects to sample-match
    :param fingerprints: List of Fingerprint objects to sample-match
    :param feature_table: Placeholder for now
    :return:
    """
    groupings: list[Grouping] = []
    grouped_injection_uuids: set[int] = set()

    for fingerprint in fingerprints:
        fp_grouped = False

        for injection in injections:
            if (injection.uuid not in grouped_injection_uuids and
                match_by_checking_delimiters(
                    fingerprint.samplename, injection.filename
                )
            ):
                groupings.append(
                    (fingerprint, injection, None)
                )

                grouped_injection_uuids.add(
                    injection.uuid
                )

                fp_grouped = True
                break

        # Add fingerprint-only grouping if no injection matched
        if not fp_grouped:
            groupings.append(
                (fingerprint, None, None)
            )

    # Add injection-only groupings for unmatched injections
    for injection in injections:
        if injection.uuid not in grouped_injection_uuids:
            groupings.append(
                (None, injection, None)
            )

    return groupings



def match_by_checking_delimiters(
    str_a: str,
    str_b: str,
)-> bool:
    """
    Determines if a samplename matches a filename
    """
    delimiters = {'_', '-', '.', ' ', '/', '\\'}

    # Find all occurrences of samplename in filename
    start = 0
    while True:
        pos = str_b.find(str_a, start)
        if pos == -1:
            # Not found
            break

        # Check character before (if exists)
        char_before = str_b[pos - 1] if pos > 0 else None
        # Check character after (if exists)
        char_after = str_b[pos + len(str_a)] if pos + len(str_a) < len(str_b) else None

        # Valid match if bounded by delimiters or string boundaries
        before_ok = char_before is None or char_before in delimiters
        after_ok = char_after is None or char_after in delimiters

        if before_ok and after_ok:
            return True

        start = pos + 1

    return False


def write_uuids(
    groupings: list[Grouping],
) -> None:
    """
    Given a list of Groupings (generated by find_groups() ),
    writes the corresponding UUID into each Fingerprint/Injection object.

    :param groupings: list of Grouping, generated by find_groups()
    :return:
    """
    for grouping in groupings:
        fp, inj, ft = grouping

        if not (fp and inj):
            continue

        if fp.injection_uuid or inj.fprint_uuid:
            raise Exception(
                f"An Injection/Fingerprint was linked to more than one sample.\n"
                f"Exception caused by either "
                f"Injection: {inj.filename} or "
                f"Fingerprint: {fp.samplename}"
            )

        fp.injection_uuid = inj.uuid
        inj.fprint_uuid = fp.uuid




