"""
A dataclass storing information about which
analytes are found in a Sample.

This dataclass is generated from a 'feature table' where each
feature corresponds to *one analyte*. It's platform agnostic;
the feature table can be generated by any metabolomics package
(mzmine, ms2analyte, etc), as long as the .csv file adheres to a
specific format

Contains optional methods for extracting MS data from the
sample's Injection object, if it exists.

This is used for visualization, and for integration with MS annotation
packages such as SIRIUS.
"""
import pandas as pd

from dataclasses import dataclass, field
import uuid

from core.interfaces.data_sources import AnalyteSource
from core.data_structs.analyte import Analyte

from typing import Optional, TYPE_CHECKING
if TYPE_CHECKING:
    import numpy as np
    from core.data_structs import (
        AnalyteTableUUID,
        AnalyteID,
        SampleUUID,
    )


REQUIRED_COLUMNS = [
    'm/z',
    'rt',
]

@dataclass
class AnalyteTable(AnalyteSource):
    """
    Represents *aligned* MS features across a batch of samples

    Loosely coupled to a group of Sample objects
    """
    data: pd.DataFrame  # rows = features, cols = samples
    uuid: 'AnalyteTableUUID' = field(
        default_factory=lambda: uuid.uuid4().int
    )
    analytes: dict['AnalyteID', 'Analyte'] = field(
        default_factory=dict
    )
    metadata: pd.DataFrame = field(
        default_factory=pd.DataFrame
    )


    def __post_init__(self):
        for col in REQUIRED_COLUMNS:
            if col not in self.data.columns:
                raise ValueError(
                    f"Table is missing the following column: {col}.\n"
                    f"These columns are required: {REQUIRED_COLUMNS}"
                )

        self._generate_analytes()


    def _generate_analytes(self) -> None:
        """
        Called on initialization;
        generates Analyte objects from the loaded DataFrame
        :return:
        """
        for analyte_id, row in self.data.iterrows():
            analyte_id: 'AnalyteID'
            row_dict = row.to_dict()
            mz = row_dict.pop('m/z')
            rt = row_dict.pop('rt')

            analyte = Analyte(
                id=analyte_id,
                mz=mz,
                rt=rt,
                intsys=row_dict,
            )

            self.analytes[analyte_id] = analyte

        for analyte_id, row in self.metadata.iterrows():
            analyte_id: 'AnalyteID'
            row_dict = row.to_dict()

            self.analytes[analyte_id].set_metadata(
                row_dict
            )


    def get_analyte_ids(self) -> list['AnalyteID']:
        return list(self.analytes.keys())


    def get_analyte(
        self,
        analyte_id: 'AnalyteID',
    ) -> Optional['Analyte']:
        return self.analytes.get(analyte_id)


    def get_sample_names(self) -> list[str]:
        sample_names = set([])
        for analyte in self.analytes.values():
            sample_names.update(analyte.get_sample_names())

        return list(sample_names)


    def get_analytes_by_sample_uuid(
        self,
        uuid: 'SampleUUID',
    ) -> list['Analyte']:
        pass


    def get_analytes_by_sample_name(
        self,
        sample_name: str,
    ) -> list['Analyte']:
        pass


    def analyte_count(self) -> int:
        return len(self.analytes)


    def sample_count(self) -> int:
        return len(
            self.get_sample_names()
        )

    def get_rt(
        self,
        analyte_id: 'AnalyteID',
    ) -> float:
        return self.analytes[analyte_id].rt

    def get_mz(
        self,
        analyte_id: 'AnalyteID',
    ) -> float:
        return self.analytes[analyte_id].mz

    def get_intsy(
        self,
        analyte_id: 'AnalyteID',
        sample_name: str,
    ) -> Optional[float]:
        return self.analytes[analyte_id].intsys.get(
            sample_name
        )

    def set_analyte_metadata(
        self,
        analyte_id: 'AnalyteID',
        metadata: dict['str', any],
    ):
        analyte = self.get_analyte(analyte_id)
        analyte.set_metadata(metadata)

    def set_analyte_srpnt_array(
        self,
        analyte_id: 'AnalyteID',
        srpnt_array: 'np.ndarray[...,]'
    ):
        analyte = self.get_analyte(analyte_id)
        analyte.set_srpnt_array(srpnt_array)

    def get_metadata_fields(self) -> list[str]:
        fields = set([])

        for analyte in self.analytes.values():
            fields.update(
                analyte.metadata.keys()
            )

        return list(fields)

