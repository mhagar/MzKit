import numpy as np
import pyqtgraph as pg
from PyQt5 import QtCore, QtWidgets, QtGui
from PyQt5.QtCore import QPointF

from gui.widgets.CustomAxisItems import IntsyAxisItem
from gui.widgets.TextOverlay import TextOverlay

from typing import Optional, Literal, TYPE_CHECKING
if TYPE_CHECKING:
    from core.data_structs import (
        EnsembleUUID,
    )


class ChromPlotWidget(pg.PlotWidget):
    """
    Custom PlotWidget with sensible behaviour for zooming/panning chromatograms
    """
    sigChromatogramHovered = QtCore.pyqtSignal(QPointF)
    sigChromatogramLeaved = QtCore.pyqtSignal()
    sigChromatogramClicked = QtCore.pyqtSignal()

    def __init__(self, *args, **kwargs):
        super(ChromPlotWidget, self).__init__(
            *args,
            **kwargs,
            plotItem=ChromPlotItem(
                plot_widget=self,
                axisItems={
                    'left': IntsyAxisItem('left')
                }
            ),
        )
        self.setBackground(None)
        self.pi: ChromPlotItem = self.getPlotItem()

        # Set up floating label
        self.floating_label = QtWidgets.QLabel(self)
        self.floating_label.setStyleSheet(
            "QLabel { color: black; background-color: rgba(225, 225, 225, 128) }"
        ) # TODO: experiment with translucent background
        self.floating_label.move(60, 5)
        self.floating_label.raise_()

        # Set up region window selector
        self.window_selector: Optional[pg.LinearRegionItem] = None
        self.window_selector_chrom: Optional[ChromGraphicItem] = None


    def mouseMoveEvent(self, ev):
        # Call original parent behaviour
        super(ChromPlotWidget, self).mouseMoveEvent(ev)

        # Emit mouse location in scene coordinates
        pos: QPointF = ev.pos()
        if not self.sceneBoundingRect().contains(pos):
            return

        vb: ChromViewBox = self.getViewBox()
        self.sigChromatogramHovered.emit(
            vb.mapSceneToView(pos)  # QPointF
        )

    def update_label(
            self,
            text: str,
    ):
        self.floating_label.setText(text)
        self.floating_label.raise_()

        # Force a refresh of the widget stack
        self.floating_label.setParent(None)
        self.floating_label.setParent(self)
        self.floating_label.show()

    def setChromArray(
            self,
            chroms: list[np.ndarray] | np.ndarray,
            max_opacity: Optional[int] = None,
            replace: bool = True,
    ):
        self.pi.addChroms(
            chroms,
            max_opacity,
            replace=replace,
        )

    def addHighlight(
        self,
        chrom: np.ndarray,
        replace: bool = True,
        color: str | QtGui.QColor = 'm',
    ):
        """
        These are intended for transient display, i.e. they're
        not tracked because they're not intended to be selectable
        """
        if replace:
            self.clearHighlights()

        self.pi.addHighlight(chrom, color)

    def addPeak(
        self,
        chrom: np.ndarray,
        uuid: 'EnsembleUUID',
        color: Optional[ str | QtGui.QColor  ] = None
    ):
        """
        Adds a *selectable* ChromGraphicItem and maintains a record of
        them. This is more permanent than the graphics generated by `addHighlight()`
        :param chrom: ChromArray
        :param uuid: unique ID used to identify this peak
        :param color: If none given, generates a random colour
        :return:
        """
        self.pi.addPeak(
            chrom, uuid, color
        )

    def removePeak(
        self,
        uuid: 'EnsembleUUID',
    ):
        """
        Wrapper around ChromPlotItem.removePeak()
        """
        self.pi.removePeak(uuid)

    def clearPeaks(self):
        """
        Wrapper around ChromPlotItem.clearPeaks()
        """
        self.pi.clearPeaks()

    def addWindowSelector(
        self,
        bounds: tuple[float, float],
        display_arr: Optional[np.ndarray],
    ):
        """
        Adds a LinearRegionItem that can be used to select
        scan window duration

        :param bounds: tuple(start, end) in rt
        :param display_arr: (Optional) a chromarray to draw while user selects
        """
        self.window_selector = pg.LinearRegionItem(
            pen=pg.mkPen('green'),
            brush=pg.mkBrush(None),
        )
        self.window_selector.setRegion(bounds)
        self.addItem(
            self.window_selector
        )

        if display_arr is not None:
            self.window_selector_chrom = ChromGraphicItem(
                rt_arr=display_arr['rt'],
                intsy_arr=display_arr['intsy'],
                pen=pg.mkPen('r')
            )
            self.addItem(
                self.window_selector_chrom
            )

    def clearWindowSelector(self):
        self.removeItem(
            self.window_selector
        )
        self.removeItem(
            self.window_selector_chrom
        )

        self.window_selector = None
        self.window_selector_chrom = None

    def clearHighlights(self):
        """
        Clears transiently displayed highlight traces
        """
        self.pi.clearHighlights()


    def setSliderSelector(
            self,
            xpos: float,
    ):
        """
        Adds a slider widget that can be used to select specific scans
        """
        self.pi.setSliderSelector(
            xpos=xpos
        )

    def setSliderSelectorMovable(
        self,
        enabled: bool,
    ):
        """
        Makes the slider selector widget movable/unmovable
        """
        self.pi.selection_indicator.setMovable(enabled)
        if enabled:
            self.pi.selection_indicator.setHoverPen(
                pg.mkPen('yellow')
            )

        if not enabled:
            self.pi.selection_indicator.setHoverPen(
                None
            )

    def setSelectionIndicator(
        self,
        xpos: float,
    ):
        self.pi.setSelectionIndicator(xpos)

    def setSelectionIndicatorVisible(
        self,
        visible: bool,
    ):
        self.pi.setSelectionIndiciatorVisible(visible)



class ChromPlotItem(pg.PlotItem):
    """
    Custom PlotItem implementing features such as:
     - Hover-detection
     - LC/MS-specific auto-panning behaviour
     - Performant chromatogram and peak drawing
    """
    def __init__(
            self,
            plot_widget: ChromPlotWidget,
            *args,
            **kwargs,
    ):
        super(ChromPlotItem, self).__init__(
            *args,
            **kwargs,
            viewBox=ChromViewBox(
                defaultPadding=0.0,
            )
        )
        self.plot_widget = plot_widget

        # Slider/selector
        self.slider_selector = pg.InfiniteLine(
            pos=0,
            movable=False,
            angle=90,
        )
        self.slider_selector.setVisible(False)
        self.addItem(
            self.slider_selector
        )

        # Indicator to show selected spectrum/slice
        self.selection_indicator = pg.InfiniteLine(
            pos=0,
            movable=False,
            angle=90,
            pen=pg.mkPen('r')
        )
        self.selection_indicator.setVisible(False)
        self.addItem(
            self.selection_indicator
        )

        # Text Overlay (Upper left corner)
        self.text_overlay = TextOverlay(
            text="",
            offset=(50, -10),
        )
        self.text_overlay.setParentItem(self)

        # State tracking
        self.highlight_trace: Optional[ ChromGraphicItem ] = None
        self.chrom_items: list[ChromGraphicItem] = []
        self.peak_overlays: dict['EnsembleUUID', ChromGraphicItem] = {}

    def addChroms(
        self,
        arrs: list[np.ndarray] | np.ndarray,
        max_opacity: Optional[int] = None,
        color: Optional[QtGui.QColor] = None,
        replace: bool = True,
    ) -> None:
        """
        Adds a chromatogram to plot

        Can also accept a list of np.arrays objects;

        if no `color`, but `max_opacity` is specified, adjusts
        the translucency depending on how many chromatograms are being 'stacked'
        """
        if not isinstance(arrs, list):
            arrs: list[np.ndarray] = [arrs]

        if replace:
            self.clear_plots()

        adaptive_alpha = 160
        if max_opacity:
            # If max_opacity is specified, adjust alpha value
            adaptive_alpha = int(max_opacity / len(arrs))

        if not color:
            color = pg.mkColor(
                150,  # R
                150,  # G
                150,  # B
                adaptive_alpha,  # Variable alpha channel
            )

        for arr in arrs:
            arr: np.ndarray
            rt_arr, intsy_arr = (arr['rt'], arr['intsy'])

            chrom_graphic_item = ChromGraphicItem(
                rt_arr=rt_arr,
                intsy_arr=intsy_arr,
                pen=pg.mkPen(
                    color,
                )
            )

            chrom_graphic_item.setZValue(-1000)

            self.chrom_items.append(
                chrom_graphic_item
            )

            self.addItem(
                chrom_graphic_item
            )

    def addHighlight(
        self,
        chrom: np.ndarray,
        color: str | QtGui.QColor = 'm'
    ):
        """
        Adds a highlight/chromatogram tracer to the plot. This is intended
        to be transient.
        """
        rt_arr, intsy_arr = (chrom['rt'], chrom['intsy'])
        chrom_graphic_item = ChromGraphicItem(
            rt_arr=rt_arr,
            intsy_arr=intsy_arr,
            pen=pg.mkPen(color),
        )

        chrom_graphic_item.setZValue(-500)

        self.highlight_trace = chrom_graphic_item
        self.addItem(self.highlight_trace)

    def clearHighlights(self):
        """
        Removes the highlight/chromatogram tracer from the plot
        """
        self.removeItem(self.highlight_trace)

    def addPeak(
        self,
        chrom: np.ndarray,
        uuid: 'EnsembleUUID',
        color: Optional[str | QtGui.QColor] = None
    ):
        """
        Adds a more permanent peak overlay to the plot. This can be selected/hovered on
        """
        rt_arr, intsy_arr = (
            chrom['rt'], chrom['intsy'],
        )

        if not color:
            color = pg.intColor(uuid)

        chrom_graphic_item = ChromGraphicItem(
            rt_arr=rt_arr,
            intsy_arr=intsy_arr,
            pen=pg.mkPen(color)
        )

        self.peak_overlays[uuid] = chrom_graphic_item

        self.addItem(
            self.peak_overlays[uuid]
        )

    def removePeak(
        self,
        uuid: 'EnsembleUUID'
    ):
        """
        Given a specific EnsembleUUID, removes the corresponding
        PeakOverlay if it exists
        """
        chrom_graphic_item = self.peak_overlays.get(uuid)
        if chrom_graphic_item:
            self.removeItem(
                chrom_graphic_item
            )

            del self.peak_overlays[uuid]

    def clearPeaks(
        self,
    ):
        """
        Remove all PeakOverlays
        """
        for _, chrom_graphic_item in self.peak_overlays.items():
            self.removeItem(
                chrom_graphic_item
            )

        self.peak_overlays.clear()

    def scaleViewboxToPeakArray(
            self,
            peak_array: np.ndarray,
    ) -> None:
        """
        Pans the viewbox in the X-axis such that it fits a mz/intsy array.
        If the viewbox scale is too small to fit the peak, increases size
        accordingly.

        Note: this is distinctly different from the scaling system in
        MSPlotItem. I think this makes more sense for chromatograms.
        """
        # Find min/max retention time of the plotted chrompeak_arrays
        min_rt: float = peak_array['rt'].min()
        max_rt: float = peak_array['rt'].max()

        # Check if this fits within the currently displayed X-range
        view_left, view_right = self.vb.viewRange()[0]
        view_left: float
        view_right: float

        # If peak is outside the range, 'pan' the view accordingly
        if min_rt < view_left:
            diff = view_left - min_rt
            view_left -= diff
            view_right -= diff

        if view_right < max_rt:
            diff = max_rt - view_right
            view_right += diff
            view_left += diff

        self.vb.setXRange(
            min=view_right,
            max=view_left,
        )

    def clear_plots(
            self,
    ):
        for chrom_plotdataitem in self.chrom_items:
            self.removeItem(chrom_plotdataitem)

        # for peak_plotdataitem in self.peak_plotdataitems:
        #     self.removeItem(peak_plotdataitem)

        # Reset state
        self.chrom_items: list[ChromGraphicItem] = []

    def setSliderSelector(
            self,
            xpos: float,
    ):
        """
        Moves the vertical slider/selector
        (i.e. for selecting specific scans)
        """
        self.slider_selector.setPos(xpos)

    def setSelectionIndicator(
        self,
        xpos: float,
    ):
        """
        Moves the selection indicator
        (Doesn't respond to mouse movements;
        shows which spectrum is currently viewed)
        """
        self.selection_indicator.setPos(xpos)

    def setSelectionIndiciatorVisible(
        self,
        visible: bool,
    ):
        self.selection_indicator.setVisible(visible)


    def mousePressEvent(self, ev):
        super().mousePressEvent(ev)

        if not ev:
            return

        self.plot_widget.sigChromatogramClicked.emit()


    def hoverEvent(self, ev):
        super().hoverEvent(ev)
        if not ev:
            return

        if ev.exit:
            self.plot_widget.sigChromatogramLeaved.emit()


class ChromViewBox(pg.ViewBox):
    """
    Custom ViewBox with sensible behaviour for zooming/panning MS data
    """
    def __init__(
            self,
            *args,
            **kwargs,
    ):
        super(ChromViewBox, self).__init__(*args, **kwargs)

    def mouseDoubleClickEvent(self, ev):
        self.autoRange()
        print("ChromViewBox double clicked")

    def mouseDragEvent(self, ev, axis=None):
        # if axis is specified, event will only affect that axis.
        ev.accept()  # we accept all buttons

        pos = ev.pos()
        lastPos = ev.lastPos()
        dif = pos - lastPos
        dif = dif * -1

        # Ignore axes if mouse is disabled
        mouseEnabled = np.array(self.state['mouseEnabled'], dtype=np.float64)
        mask = mouseEnabled.copy()
        if axis is not None:
            mask[1 - axis] = 0.0

        # Scale or translate based on mouse button
        if ev.button() in [QtCore.Qt.MouseButton.LeftButton, QtCore.Qt.MouseButton.MiddleButton]:
            if self.state['mouseMode'] == pg.ViewBox.RectMode and axis is None:
                if ev.isFinish():  # This is the final move in the drag; change the view scale now
                    # print "finish"
                    self.rbScaleBox.hide()
                    ax = QtCore.QRectF(pg.Point(ev.buttonDownPos(ev.button())), pg.Point(pos))
                    ax = self.childGroup.mapRectFromParent(ax)
                    self.showAxRect(ax)
                    self.axHistoryPointer += 1
                    self.axHistory = self.axHistory[:self.axHistoryPointer] + [ax]
                else:
                    # update shape of scale box
                    self.updateScaleBox(ev.buttonDownPos(), ev.pos())
            else:
                tr = self.childGroup.transform()
                tr = pg.functions.invertQTransform(tr)
                tr = tr.map(dif * mask) - tr.map(pg.Point(0, 0))

                x = tr.x() if mask[0] == 1 else None
                y = tr.y() if mask[1] == 1 else None

                self._resetTarget()
                if x is not None or y is not None:
                    self.translateBy(x=x, y=0)  # (x=x, y=y)
                self.sigRangeChangedManually.emit(self.state['mouseEnabled'])

        elif ev.button() & QtCore.Qt.MouseButton.RightButton:
            # print "vb.rightDrag"
            if self.state['aspectLocked'] is not False:
                mask[0] = 0

            dif = ev.screenPos() - ev.lastScreenPos()
            dif = np.array([dif.x(), dif.y()])
            dif[0] *= -1
            s = ((mask * 0.02) + 1) ** dif

            tr = self.childGroup.transform()
            tr = pg.functions.invertQTransform(tr)

            # Sets either the x or y scaling factor to 0 depending on whether
            #  the mouse is hovering over the axis
            # s = np.multiply(s, mask)
            # s[s == 0.] = None

            x = s[0] if mouseEnabled[0] == 1 else None
            y = s[1] if mouseEnabled[1] == 1 else None
            if mask[1] != 1:
                y = None   # Disables y-scaling if not dragging on y-axis

            center = pg.Point(tr.map(ev.buttonDownPos(QtCore.Qt.MouseButton.RightButton)))
            center[1] = 0  # Set the center-point's y-value to be 0

            self._resetTarget()
            self.scaleBy(x=x, y=y, center=center)
            self.sigRangeChangedManually.emit(self.state['mouseEnabled'])

    def wheelEvent(self, ev, axis=None):
        """
        Overwrites ViewBox methods to behave more sensibly for MS data
        """

        # Retrieve scaling factor setting
        s = 1.02 ** (ev.delta() * self.state['wheelScaleFactor'])

        center = pg.Point(pg.functions.invertQTransform(self.childGroup.transform()).map(ev.pos()))
        if axis == 0:  # If mouse is hovering on X-axis:
            s = [s, None]  # Don't zoom in the y-direction

        else:  # Otherwise,
            s = [None, s]  # Don't zoom in the x-direction
            center[1] = 0  # Set the center-point's y-value to be 0
            # This is so the plot zooms by 'stretching upwards'

        self._resetTarget()
        self.scaleBy(s, center=center)
        ev.accept()

        # This block might be unneccessary, but included so nothing breaks
        if axis in (0, 1):
            mask = [False, False]
            mask[axis] = self.state['mouseEnabled'][axis]
        else:
            mask = self.state['mouseEnabled'][:]

        self.sigRangeChangedManually.emit(mask)


class ChromGraphicItem(pg.GraphicsObject):
    """
    Custom GraphicsObject for performant chromatogram drawings

    Note: rt_arr and intsy_arr *MUST* be equal length. This object will NOT
    check if this is true (for efficiency)
    """
    def __init__(
        self,
        rt_arr: np.ndarray,
        intsy_arr: np.ndarray,
        pen: QtGui.QPen,
    ):
        pg.GraphicsObject.__init__(self)
        self.rt_arr = rt_arr
        self.intsy_arr = intsy_arr
        self.pen = pen

        self.picture: QtGui.QPicture = QtGui.QPicture()
        self.generatePicture()

    def generatePicture(self):
        """
        Precompute QPicture object so paint() runs quickly
        """
        p = QtGui.QPainter(self.picture)
        p.setPen(self.pen)

        for i in range(len(self.rt_arr) - 1):
            point_a = QtCore.QPointF(
                self.rt_arr[i] ,
                self.intsy_arr[i],
            )

            point_b = QtCore.QPointF(
                self.rt_arr[i + 1] ,
                self.intsy_arr[i + 1],
            )

            p.drawLine(
                point_a,
                point_b,
            )

        p.end()

    def paint(self, p, *args):
        p.drawPicture(0, 0, self.picture)

    def boundingRect(self):
        """
        This MUST indicate area that will be drawn or we will get
        artifacts or even crashing
        """
        return QtCore.QRectF(self.picture.boundingRect())








